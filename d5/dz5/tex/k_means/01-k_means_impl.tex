\item\subquestionpoints{70}
\textbf{[Програмерски задатак] Имплементација компресије методом $k$-средњих вредности.}
Најпре \emph{погледајмо} податке. Унутар \texttt{src/k\_means/} директоријума покренути интерактивни Пајтон интерпретатор и у њему укуцати
%
\begin{center}
  \texttt{from matplotlib.image import imread; import matplotlib.pyplot as plt;}
\end{center}
%
а затим покренути \texttt{A = imread(`peppers-large.tiff')}. Сада је \texttt{A} заправо ``тродимензионална матрица'' где су \texttt{A[:,:,0]}, \texttt{A[:,:,1]} и \texttt{A[:,:,2]} дводимензионални низови димензија 512$\times$512 који респективно садрже вредности црвене, зелене и плаве боје за сваки од пиксела. Слика се може приказати у новом прозору уносом \texttt{plt.imshow(A); plt.show()} наредби.

Пошто већа слика има укупно 262144 пиксела па поступак кластеризације може потрајати, векторска квантизација биће урађена на мањој слици. Стога је неопходно поновити претходни поступак за \texttt{peppers-small.tiff} датотеку.

Надаље ће бити имплементирана компресија слике с губицима у датотеци \texttt{src/k\_means/k\_means.py} у којој се налази шаблон. Третирајући $(r, g, b)$ вредности сваког пиксела као елемент $\Re^3$ простора, имплементирати методу $k$-средњих са 16 кластера над вредностима пиксела у мањој слици итерирајући све до конвергенције. У сврху иницијализације, поставити центроиде сваког од кластера на $(r, g, b)$ вредности случајно изабраних пиксела у слици.

Затим у слици \texttt{peppers-large.tiff} заменити $(r, g, b)$ вредности сваког пиксела са вредношћу њој најближег центроида из скупа центроида израчунатих над \texttt{peppers-small.tiff} сликом. Визуелно упоредити новодобијену слику са оригиналном како би се проверила исправност имплементације. \textbf{Укључити у извештај компресовану слику, поред оригиналне.}

